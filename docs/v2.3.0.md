# Spark Messaging 프로젝트 개선 설계안 (v2.3.0)

## 1. 아키텍처 목표: Fat Server, Thin Client

- **핵심 원칙**: 모든 비즈니스 로직과 상태 변화의 최종 결정권(Source of Truth)은 **백엔드**가 가짐.
- **프론트엔드 역할**: 서버로부터 수신된 데이터를 UI에 반영하고, 사용자 액션을 서버에 전달하는 역할로 최소화.

---

## 2. 주요 설계 전략

### A. 사용자 접속 상태 관리 (Presence Management)

- **서버 주도 업데이트**: 소켓 `connection`/`disconnection` 이벤트를 통해 서버가 직접 DB의 `User.status`를 관리.
- **실시간 전파**: 상태 변경 시 서버가 관련 사용자들에게 `USER_STATUS_CHANGED` 이벤트를 브로드캐스트.
- **비정상 종료 대응**: Heartbeat 체크를 통해 클라이언트가 비정상적으로 꺼져도 서버가 '오프라인'으로 강제 전환.

### B. 원자적 비즈니스 로직 (Atomic Operations)

- **로직 캡슐화**: 프론트엔드에서 여러 단계를 거치던 로직을 서버 측 단일 트랜잭션으로 통합.
- **예시 (채팅방 퇴장)**:
  1. 클라이언트는 `REQUEST_LEAVE_ROOM` 단일 요청 발송.
  2. 서버는 DB 업데이트(멤버 제거), 시스템 메시지 생성, 타 멤버 대상 소켓 알림을 모두 처리.
  3. 클라이언트는 최종 성공 응답(또는 이벤트)을 받고 UI만 갱신.

### C. 데이터 정합성 및 시퀀싱 (Data Integrity)

- **메시지 시퀀싱**: 각 채팅방별로 서버가 고유한 `sequenceNumber`를 순차적으로 부여.
- **누락 감지**: 클라이언트는 수신된 번호 중 빠진 번호가 있다면 서버에 즉시 `REQUEST_SYNC` 요청.
- **에러 핸들링**: 백엔드 응답에 `action: ROLLBACK` 지시를 포함하여, 실패 시 프론트엔드가 낙관적 업데이트를 되돌릴 수 있도록 설계.

### D. 동기화 및 오버헤드 최적화 (Event Filtering)

- **구독 모델**: 사용자의 상태에 따라 소켓 채널(Room)을 분리하여 불필요한 트래픽 차단.
  - `User 채널`: 개인 알림, 안읽음 카운트
  - `Room 채널`: 내가 속한 방들의 메시지
  - `Active Room 채널`: 현재 열어보고 있는 방의 실시간 상태 (입력 중 등)
- **로그인 동기화 (Login-Sync)**:
  - 로그인 시점에 안읽은 메시지가 있는 방 목록과 카운트 요약을 한 번에 수신.
  - **전체 공지**: 로그인 직후, 로그아웃 기간 동안 발생한 전체 공지를 앱 내 푸시(토스트/알림창)로 즉시 전송.

---

## 3. 세부 구현 검토 사항 (To-do)

1. **전체 알림 스펙 정의**: 텍스트 외에 랜딩 URL, 이미지 등 메타데이터 포함 여부 결정.
2. **안읽음 카운트 최적화**: 메시지 발생 시마다 `UserChatRoom` 테이블의 `unreadCount`를 증감시키는 방식 검토.
3. **API/소켓 명세 업데이트**: 위 원칙에 맞춰 `chatController.js` 및 `socketService.js` 핸들러 재설계.

---

# 상세설명

1. 동기화 오버헤드 관리 (Event Routing & Filtering)
   모든 이벤트를 모든 사용자에게 뿌리는 것이 아니라, 사용자의 상태(Context)에 따라 서버가 이벤트를 필터링하여 전송합니다.
   구독(Subscription) 계층 설계:
   User 채널 (Private): 로그인한 본인에게만 해당하는 이벤트 (내 안읽음 카운트 변경, 누군가 나를 멘션함, 개인 설정 변경).
   Room 채널 (Member-only): 내가 속한 채팅방의 이벤트 (새 메시지, 멤버 출입, 마지막 메시지 업데이트).
   Active Room 채널 (Focus-only): 내가 현재 열어보고 있는 방의 상세 이벤트 (상대방이 입력 중, 메시지 읽음 처리).
   Global 채널 (Broadcast): 서비스 전체 공지, 시스템 점검 알림.
   서버 로직: 사용자가 특정 방에 들어가면 socket.join(roomId)을 통해 해당 방의 상세 이벤트를 수신하기 시작하고, 방에서 나가면 leave 처리를 하여 불필요한 트래픽을 차단합니다.
2. 오프라인 메시지 및 로그인 시 알림 (Login-Sync Flow)
   로그아웃 상태에서의 불필요한 푸시는 줄이고, 로그인 시점에 필요한 정보를 동기화하는 전략입니다.
   채팅방 목록 (Lazy Loading):
   사용자가 로그인하면 서버는 사용자가 속한 방 목록과 각 방의 unreadCount를 포함한 데이터를 한 번에 내려줍니다. (현재 방식 유지)
   중요: 로그아웃 중에 쌓인 개별 메시지 하나하나를 푸시로 보내는 것이 아니라, 로그인 시점에 "어느 방에 안 읽은 메시지가 몇 개 있다"는 요약 정보만 동기화합니다.
   전체 알림 (Global Push on Login):
   서버 로직: GlobalAnnouncement 테이블에 공지사항을 관리합니다.
   사용자가 소켓에 연결되는(Connection) 즉시, 서버는 user.lastLogoutTime 이후에 생성된 '전체 공지'가 있는지 확인합니다.
   새로운 공지가 있다면 소켓 이벤트(예: GLOBAL_NOTIFICATION_RECEIVED)를 통해 클라이언트에 즉시 쏘아줍니다.
   클라이언트 처리: 로그인 직후 수신된 전체 공지는 토스트(Toast)나 팝업으로 노출하여 사용자가 바로 인지하게 합니다.
3. 백엔드 중심의 설계 요약 (Sequence & Authority)
   항목 백엔드 역할 (Authority) 프론트엔드 역할 (UI/UX)
   메시지 순서 DB 저장 시 sequenceNumber 할당 및 보장 번호에 맞춰 정렬 및 누락 번호 감지 시 재요청
   로그인 상태 소켓 연결/해제 시 DB 업데이트 및 브로드캐스트 서버가 알려주는 상태값대로 아이콘 표시
   방 나가기 DB 수정 + 시스템 메시지 생성 + 멤버들에게 알림 성공 응답 받으면 목록에서 해당 방 제거
   에러 발생 실패 원인과 함께 ROLLBACK 지시 전달 낙관적 업데이트로 그린 요소 제거 및 에러 알림
   논의해볼 만한 "두리뭉실한" 지점:
   전체 알림의 정의: "전체 공지"가 단순히 텍스트 메시지인지, 아니면 클릭 시 특정 페이지로 이동해야 하는 등의 추가 메타데이터가 필요한지 정의가 필요합니다.
   안읽음 카운트 계산: 백엔드에서 unreadCount를 매번 쿼리로 계산할지, 아니면 UserChatRoom 테이블 등에 숫자로 저장해두고 메시지가 올 때마다 +1 시킬지에 대한 방식 선택이 필요합니다. (성능과 직결됨)
   로그인 즉시 푸시 방식: 웹푸시(브라우저 알림) 방식인가요, 아니면 앱 내 UI(토스트/알림창)에 뜨는 방식인가요? 말씀하신 "로그인 되자마자 웹푸쉬"는 후자(앱 내 알림)에 더 가까워 보입니다.
   이 방향으로 설계를 구체화하면 프론트엔드의 비중이 확연히 줄어들고, 백엔드에서 데이터의 흐름을 꽉 잡을 수 있게 됩니다. 다음 단계로 특정 도메인(예: 채팅방 퇴장 로직)의 API/소켓 명세부터 그려볼까요?

_기록 일시: 2026-01-12_
