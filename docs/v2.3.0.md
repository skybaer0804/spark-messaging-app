# Spark Messaging 프로젝트 개선 설계안 (v2.3.0)

## 1. 아키텍처 목표: Fat Server, Thin Client

- **핵심 원칙**: 모든 비즈니스 로직과 상태 변화의 최종 결정권(Source of Truth)은 **백엔드**가 가짐.
- **프론트엔드 역할**: 서버로부터 수신된 데이터를 UI에 반영하고, 사용자 액션을 서버에 전달하는 역할로 최소화.

---

## 2. 주요 설계 전략

### A. 사용자 접속 상태 관리 (Presence Management)

- **서버 주도 업데이트**: 소켓 `connection`/`disconnection` 이벤트를 통해 서버가 직접 DB의 `User.status`를 관리.
- **실시간 전파**: 상태 변경 시 서버가 관련 사용자들에게 `USER_STATUS_CHANGED` 이벤트를 브로드캐스트.
- **비정상 종료 대응**: Heartbeat 체크를 통해 클라이언트가 비정상적으로 꺼져도 서버가 '오프라인'으로 강제 전환.

### B. 원자적 비즈니스 로직 (Atomic Operations)

- **로직 캡슐화**: 프론트엔드에서 여러 단계를 거치던 로직을 서버 측 단일 트랜잭션으로 통합.
- **채팅방 퇴장(Leave Room) 정책**:
  1. **메시지 유지**: 사용자가 그룹 채팅방을 나가더라도, 이전에 작성한 메시지는 삭제하지 않고 그대로 유지.
  2. **남은 인원 알림**: 해당 방에 남아있는 멤버들에게 "OOO님이 나갔습니다"라는 시스템 메시지와 소켓 이벤트 전송.
  3. **나간 본인 처리**: 본인의 전체 채팅방 목록 UI에서도 즉시 해당 방이 제거되도록 백엔드가 처리 및 응답.
- **예시**:
  1. 클라이언트는 `REQUEST_LEAVE_ROOM` 단일 요청 발송.
  2. 서버는 DB 업데이트(멤버 제거), 시스템 메시지 생성, 타 멤버 대상 소켓 알림, 본인에 대한 목록 갱신 응답을 모두 처리.
  3. 클라이언트는 서버 응답 객체를 수동적으로 반영하여 UI만 갱신.

### C. 데이터 정합성 및 Server-Side State Authority

- **최종 결정권**: 모든 상태 변화의 최종 데이터는 백엔드 응답이 기준임.
- **프론트엔드 간소화**: 프론트엔드의 복잡한 Reducer 및 상태 계산 로직을 제거하고, 백엔드가 내려주는 완성된 객체를 그대로 Store에 반영하도록 리팩토링.
- **메시지 시퀀싱**: 각 채팅방별로 서버가 고유한 `sequenceNumber`를 순차적으로 부여.
- **누락 감지**: 클라이언트는 수신된 번호 중 빠진 번호가 있다면 서버에 즉시 `REQUEST_SYNC` 요청.
- **에러 핸들링**: 백엔드 응답에 `action: ROLLBACK` 지시를 포함하여, 실패 시 프론트엔드가 낙관적 업데이트를 되돌릴 수 있도록 설계.

### D. 동기화 및 오버헤드 최적화 (Event Filtering)

- **구독 모델**: 사용자의 상태에 따라 소켓 채널(Room)을 분리하여 불필요한 트래픽 차단.
  - `User 채널`: 개인 알림, 안읽음 카운트
  - `Room 채널`: 내가 속한 방들의 메시지
  - `Active Room 채널`: 현재 열어보고 있는 방의 실시간 상태 (입력 중 등)
- **로그인 동기화 (Login-Sync)**:
  - 로그인 시점에 안읽은 메시지가 있는 방 목록과 카운트 요약을 한 번에 수신.
  - **전체 공지 (Global Push)**:
    - 로그인 직후, 로그아웃 기간 동안 발생한 전체 공지를 **웹 푸시(Web Push)** 방식으로 즉시 전송.
    - 서버에서 `lastLogoutAt`을 확인하여 미수신 공지를 실제 Push API를 통해 발송.
- **안읽음 카운트 관리**:
  - 성능 최적화를 위해 `UserChatRoom` 테이블에 `unreadCount`를 숫자로 직접 저장.
  - 메시지 전송 시 `$inc`를 통해 원자적으로 증가시키며, 방 입장 시 0으로 초기화.

### E. 알림 메타데이터 및 확장성 (v2.3.0)

- **알림 스펙 확장**: 단순 텍스트 외에 `actionUrl`, `metadata` 필드 추가.
- **이동 로직**: 알림 클릭 시 특정 페이지(채팅방, 공지사항 상세 등)로 즉시 이동할 수 있는 기능 제공.

---

## 3. 세부 구현 사항 (Completed)

### Step 1: 서버 주도 사용자 상태(Presence) 관리

- [x] `server/services/userService.js`: `setUserStatus` 시 MongoDB의 `User.status` 도 함께 업데이트하도록 수정.
- [x] `server/controllers/authController.js`: 로그인/로그아웃 시 Redis 상태 반영 및 `lastLogoutAt` 기록 로직 추가.
- [x] `server/services/socketService.js`: 서버 사이드 클라이언트 접속 감시 구조 준비 (주석 처리).

### Step 2: 채팅방 퇴장 로직 서버 이관 및 원자화

- [x] `server/controllers/chatController.js`: `leaveRoom` 컨트롤러 리팩토링.
- [x] 그룹 채팅방 퇴장 시 "OOO님이 나갔습니다" 시스템 메시지 생성 및 시퀀스 할당 로직 추가.
- [x] 퇴장한 본인 및 남은 멤버들에게 `ROOM_LIST_UPDATED` 이벤트를 통해 상태 동기화.

### Step 3: 메시지 시퀀싱 및 정합성 보장

- [x] `server/controllers/chatController.js`: `leaveRoom` 시스템 메시지에도 시퀀스 번호 적용 및 방의 `lastSequenceNumber` 증가 로직 반영.
- [x] `Message` 모델의 `system` 타입 활용.

### Step 4: 프론트엔드 로직 간소화 (Server-Side Authority)

- [x] `server/controllers/chatController.js`: `notifyRoomListUpdated` 시 전체 Room 객체와 개인별 `unreadCount`를 포함하여 전송하도록 고도화.
- [x] `client/src/domains/Chat/context/ChatContext.tsx`: 서버에서 온 완성된 객체를 그대로 반영하도록 리팩토링 (프론트엔드 수동 계산 로직 제거).
- [x] `client/src/domains/Chat/hooks/useChatRoom.ts`: `sendMessage` 후 수동 방 목록 업데이트 로직 제거.

### Step 5: 로그인 시 전체 공지 동기화

- [x] `server/models/User.js`: `lastLogoutAt` 필드 추가.
- [x] `server/controllers/authController.js`: 로그아웃 시 `lastLogoutAt` 기록.
- [x] `server/models/Notification.js`: `actionUrl`, `metadata` 필드 추가.
- [x] `server/controllers/notificationController.js`: `syncNotifications` API 구현 및 웹 푸시 발송 트리거 로직 추가.
- [x] `client/src/domains/Chat/context/ChatContext.tsx`: 로그인 시 미수신 공지사항 동기화 및 메타데이터(`actionUrl`) 전달.
- [x] `client/src/core/context/ToastContext.tsx`: 알림 클릭 시 이동 로직(`app-navigate`) 연동.

---

# 상세설명

1. 동기화 오버헤드 관리 (Event Routing & Filtering)
   모든 이벤트를 모든 사용자에게 뿌리는 것이 아니라, 사용자의 상태(Context)에 따라 서버가 이벤트를 필터링하여 전송합니다.
   구독(Subscription) 계층 설계:
   User 채널 (Private): 로그인한 본인에게만 해당하는 이벤트 (내 안읽음 카운트 변경, 누군가 나를 멘션함, 개인 설정 변경).
   Room 채널 (Member-only): 내가 속한 채팅방의 이벤트 (새 메시지, 멤버 출입, 마지막 메시지 업데이트).
   Active Room 채널 (Focus-only): 내가 현재 열어보고 있는 방의 상세 이벤트 (상대방이 입력 중, 메시지 읽음 처리).
   Global 채널 (Broadcast): 서비스 전체 공지, 시스템 점검 알림.
   서버 로직: 사용자가 특정 방에 들어가면 socket.join(roomId)을 통해 해당 방의 상세 이벤트를 수신하기 시작하고, 방에서 나가면 leave 처리를 하여 불필요한 트래픽을 차단합니다.
2. 오프라인 메시지 및 로그인 시 알림 (Login-Sync Flow)
   로그아웃 상태에서의 불필요한 푸시는 줄이고, 로그인 시점에 필요한 정보를 동기화하는 전략입니다.
   채팅방 목록 (Lazy Loading):
   사용자가 로그인하면 서버는 사용자가 속한 방 목록과 각 방의 unreadCount를 포함한 데이터를 한 번에 내려줍니다. (현재 방식 유지)
   중요: 로그아웃 중에 쌓인 개별 메시지 하나하나를 푸시로 보내는 것이 아니라, 로그인 시점에 "어느 방에 안 읽은 메시지가 몇 개 있다"는 요약 정보만 동기화합니다.
   전체 알림 (Global Push on Login):
   서버 로직: GlobalAnnouncement 테이블에 공지사항을 관리합니다.
   사용자가 소켓에 연결되는(Connection) 즉시, 서버는 user.lastLogoutTime 이후에 생성된 '전체 공지'가 있는지 확인합니다.
   새로운 공지가 있다면 소켓 이벤트(예: GLOBAL_NOTIFICATION_RECEIVED)를 통해 클라이언트에 즉시 쏘아줍니다.
   클라이언트 처리: 로그인 직후 수신된 전체 공지는 토스트(Toast)나 팝업으로 노출하여 사용자가 바로 인지하게 합니다.
3. 백엔드 중심의 설계 요약 (Sequence & Authority)
   항목 백엔드 역할 (Authority) 프론트엔드 역할 (UI/UX)
   메시지 순서 DB 저장 시 sequenceNumber 할당 및 보장 번호에 맞춰 정렬 및 누락 번호 감지 시 재요청
   로그인 상태 소켓 연결/해제 시 DB 업데이트 및 브로드캐스트 서버가 알려주는 상태값대로 아이콘 표시
   방 나가기 DB 수정 + 시스템 메시지 생성 + 멤버들에게 알림 성공 응답 받으면 목록에서 해당 방 제거
   에러 발생 실패 원인과 함께 ROLLBACK 지시 전달 낙관적 업데이트로 그린 요소 제거 및 에러 알림
   논의해볼 만한 "두리뭉실한" 지점:
   전체 알림의 정의: "전체 공지"가 단순히 텍스트 메시지인지, 아니면 클릭 시 특정 페이지로 이동해야 하는 등의 추가 메타데이터가 필요한지 정의가 필요합니다.
   안읽음 카운트 계산: 백엔드에서 unreadCount를 매번 쿼리로 계산할지, 아니면 UserChatRoom 테이블 등에 숫자로 저장해두고 메시지가 올 때마다 +1 시킬지에 대한 방식 선택이 필요합니다. (성능과 직결됨)
   로그인 즉시 푸시 방식: 웹푸시(브라우저 알림) 방식인가요, 아니면 앱 내 UI(토스트/알림창)에 뜨는 방식인가요? 말씀하신 "로그인 되자마자 웹푸쉬"는 후자(앱 내 알림)에 더 가까워 보입니다.
   이 방향으로 설계를 구체화하면 프론트엔드의 비중이 확연히 줄어들고, 백엔드에서 데이터의 흐름을 꽉 잡을 수 있게 됩니다. 다음 단계로 특정 도메인(예: 채팅방 퇴장 로직)의 API/소켓 명세부터 그려볼까요?

_기록 일시: 2026-01-12_
